import { ICanvas as ICanvas$1 } from '@pixi/settings';
import { gsap } from 'gsap';
import * as PIXI from 'pixi.js';
import { IRendererOptions, EventSystem, ICanvas, Renderer, IDisplayObjectExtended, DisplayObjectEvents, Container, IPoint, Texture, Loader, Rectangle, Filter, MaskData, EventMode, Cursor, IParticleProperties, ObservablePoint, Sprite, IBitmapTextStyle, BitmapText, IHTMLTextStyle, HTMLText, HTMLTextStyle, Text, ITextStyle, AnimatedSprite, IDestroyOptions, BLEND_MODES, FederatedMouseEvent, ILineStyleOptions, Graphics, ITypedArray, NineSlicePlane, ParticleContainer, TilingSprite, IHitArea, IRenderer } from 'pixi.js';
export { PIXI };
import { DisplayObject } from '@pixi/display';
import { ListenerFn as ListenerFn$1 } from 'eventemitter3';
import { Howl, HowlOptions } from 'howler';
import { SkeletonData } from '@pixi-spine/runtime-4.1';
import { ColorSource } from '@pixi/color/lib/Color';
import { BLEND_MODES as BLEND_MODES$1 } from '@pixi/constants';
import { EmitterConfigV3, EmitterConfigV1, EmitterConfigV2, Emitter } from '@pixi/particle-emitter';
import { AnimatedParticleArt } from '@pixi/particle-emitter/lib/behaviors/AnimatedTexture';
import { ValueList } from '@pixi/particle-emitter/lib/PropertyNode';
import { ArrayLike, Spine, ITrackEntry } from 'pixi-spine';
import { LoaderParser } from '@pixi/assets/lib/loader/parsers/LoaderParser';
import * as pixiProjection from 'pixi-projection';
export { pixiProjection as projection };
import { ViewExtension as ViewExtension$1 } from 'src/kernel';

declare const toFixedNumber: (value: number, decimals?: number) => number;
declare const limitBetween: (min: number, max: number, val: number) => number;
declare const randomNumber: (min: number, max: number) => number;
declare const randomInt: (min: number, max: number) => number;
declare const howSum: (targetSum: number, numbers: number[], memo?: Record<string, number[]>) => number[] | null;

declare const deepObjectMerge: <T>(source: object, target?: object) => T;

declare const getUrlParam: (item: string) => string | undefined;
declare const getAllUrlParams: <T = object>() => T;
declare const getOrigin: () => string;
declare const getFileNameFromUrl: (url: string) => string;

declare function skippablePromiseChain(promises: (() => Promise<any>)[], event: string): Promise<(() => Promise<any>)[]>;

declare const index_d_deepObjectMerge: typeof deepObjectMerge;
declare const index_d_getAllUrlParams: typeof getAllUrlParams;
declare const index_d_getFileNameFromUrl: typeof getFileNameFromUrl;
declare const index_d_getOrigin: typeof getOrigin;
declare const index_d_getUrlParam: typeof getUrlParam;
declare const index_d_howSum: typeof howSum;
declare const index_d_limitBetween: typeof limitBetween;
declare const index_d_randomInt: typeof randomInt;
declare const index_d_randomNumber: typeof randomNumber;
declare const index_d_skippablePromiseChain: typeof skippablePromiseChain;
declare const index_d_toFixedNumber: typeof toFixedNumber;
declare namespace index_d {
  export { index_d_deepObjectMerge as deepObjectMerge, index_d_getAllUrlParams as getAllUrlParams, index_d_getFileNameFromUrl as getFileNameFromUrl, index_d_getOrigin as getOrigin, index_d_getUrlParam as getUrlParam, index_d_howSum as howSum, index_d_limitBetween as limitBetween, index_d_randomInt as randomInt, index_d_randomNumber as randomNumber, index_d_skippablePromiseChain as skippablePromiseChain, index_d_toFixedNumber as toFixedNumber };
}

type GameLoadingData = {
    progress: number;
    group?: LoadGroup;
};
type AXCoreEvents = {
    render: void;
    gameLoading: GameLoadingData;
    displayDataUpdate: DisplayDataParams;
    createGameScene: string;
    runGameScene: string;
};
type EventHandler<T = unknown> = (event: T) => void;
declare class EventEmitter<Events extends AXCoreEvents> {
    ignoreList: (keyof Events)[];
    private emitter;
    private promiseMap;
    emit<Key extends keyof Events>(event: Key, args?: Events[Key]): boolean;
    on<Key extends keyof Events>(event: Key, handler: EventHandler<Events[Key]>, context?: any): this;
    once<Key extends keyof Events>(event: Key, handler: EventHandler<Events[Key]>, context?: any): this;
    off<Key extends keyof Events>(event: Key, handler: EventHandler<Events[Key]>, context?: any, once?: boolean): this;
    promiseEmit<Key extends keyof Events>(event: Key, args?: Events[Key]): Promise<any>;
    promiseOn<Key extends keyof Events>(event: Key, handler: () => Promise<any>, context?: any): void;
    promiseOff<Key extends keyof Events>(event: Key, handler: () => Promise<any>, context?: any): void;
    protected logEvent<Key extends keyof Events>(event: Key, payload: unknown, isPromise?: boolean): void;
}

declare class EventEmitterProvider<Events extends AXCoreEvents> {
    protected eventEmitter: EventEmitter<Events>;
    private listenersMap;
    private promiseMap;
    promiseEmit<Key extends keyof Events>(event: Key, payload?: Events[Key]): Promise<any>;
    promiseOn<Key extends keyof Events>(event: Key, handler: (data?: any) => Promise<any>): void;
    promiseOff<Key extends keyof Events>(event: Key, handler: (data?: any) => Promise<any>): void;
    emit<Key extends keyof Events>(type: Key, payload?: Events[Key]): void;
    on<Key extends keyof Events>(type: Key, handler: EventHandler<Events[Key]>): void;
    off<Key extends keyof Events>(type: Key, handler?: EventHandler<Events[Key]>): void;
    destroy(): void;
    protected removeAllListeners(): void;
}

type IRendererSetupOptions = Partial<IRendererOptions>;
declare class RenderManager {
    eventSystem: EventSystem;
    protected eventEmitter: EventEmitter<AXCoreEvents>;
    private _rootContainer;
    private _renderer;
    constructor();
    get canvasElement(): ICanvas;
    get renderer(): Renderer;
    get rootContainer(): AXContainer;
    createRenderer(options: IRendererSetupOptions): void;
    fps(value: number): void;
    freeze(value: boolean): void;
    gameSpeed(scale: number): void;
    prepareView(asset: IDisplayObjectExtended): Promise<void>;
    resize(width: number, height: number): void;
    private render;
    private setupRenderer;
}

type DeviceOrientation = 'portrait' | 'landscape';
type DeviceType = 'mobile' | 'tablet' | 'desktop';
type OrientationStateType = 'portrait' | 'landscape' | 'desktop' | 'tabPortrait' | 'tabLandscape';
interface IDisplaySize {
    width: number;
    height: number;
}
type DisplayOptions = {
    orientation: DeviceOrientation;
    deviceType: DeviceType;
    designSize: IDisplaySize;
    viewSize: {
        width: number;
        height: number;
    };
};
type DisplayDataParams = DisplayOptions & {
    gameScale: number;
    stateChanged: boolean;
    orientationState: OrientationStateType;
};
declare class DisplayDataManager {
    protected eventEmitter: EventEmitter<AXCoreEvents>;
    protected renderManager: RenderManager;
    private _viewSize;
    private _designSize;
    private _gameScale;
    private _stateChanged;
    private _orientation;
    private _deviceType;
    private _orientationState;
    get params(): DisplayDataParams;
    update(options: Partial<DisplayOptions>): void;
    private calcScale;
}

type SoundGroup = 'ambient' | 'sfx';
type ISoundResourceOptions<O extends boolean> = {
    name: string;
    group: SoundGroup;
    loop?: boolean;
    volume?: number;
    singleInstance?: boolean;
} & (O extends true ? {
    start?: string;
    end?: string;
} : {
    start: string;
    end: string;
});
interface ISoundResourceData {
    resourceType: 'sound';
    options: ISoundResourceOptions<true>;
}
interface ISoundSpriteResourceData {
    resourceType: 'soundSprite';
    sprite: ISoundResourceOptions<false>[];
}
declare class SoundManager<SoundsName extends string = string> {
    groupMuted: Record<SoundGroup | 'all', boolean>;
    protected sounds: Sound[];
    muteSoundGroup(name: SoundGroup, mute: boolean): void;
    fadeIn(name: SoundsName, duration: number): Promise<any>;
    fadeOut(name: SoundsName, duration: number): Promise<any>;
    getSound(name: SoundsName): Sound;
    getSoundGroup(name: SoundGroup): Sound[];
    globalMute(toMute?: boolean): void;
    globalVolume(value?: number): void | number;
    pause(name: SoundsName): void;
    play(name: SoundsName): void;
    stop(name: SoundsName): void;
    preloadSound(url: string | string[]): Promise<any>;
    registerSound(howl: Howl, options: ISoundResourceOptions<true>): Sound;
    registerSprite(howl: Howl, sprite: ISoundResourceOptions<false>[]): Sound[];
    protected parseSpriteProps(name: string, start: string, end: string): {};
    protected toMilliseconds(time: string): number;
}

declare class Sound extends Howl {
    group: SoundGroup;
    maxVolume: number;
    name: string;
    singleInstance: boolean;
    protected id: number;
    constructor(options: HowlOptions, name: string, group?: SoundGroup, singleInstance?: boolean, volume?: number, loop?: boolean);
    fadeIn(duration: number): Promise<any>;
    fadeOut(duration: number): Promise<any>;
    play(): number;
}

type ContainerChangeableParams = Partial<{
    width: number;
    height: number;
    sortableChildren: boolean;
}> & BaseGameComponentChangeableParams;
interface IContainerLayout<L = AXCoreLayouts> extends IBaseGameComponentLayout<ContainerChangeableParams> {
    selector: 'container';
    children?: L[];
}
declare class AXContainer<T extends DisplayObjectEvents = DisplayObjectEvents> extends Container implements IGameComponent {
    static appliers: PropertyApplier[];
    constructor();
    emit<Key extends keyof T>(event: Key, ...args: T[Key]): boolean;
    on<Key extends keyof T>(event: Key, handler: ListenerFn$1<T[Key]>, context?: any): this;
    applyLayout(layout: IContainerLayout): void;
    getAppliers(): PropertyApplier[];
    onDisplayDataUpdate(displayData: DisplayDataParams): void;
    protected onAdded(): void;
}
declare const applyContainerLayout: (component: AXContainer, name: string, value: any) => boolean;

interface IAutomationId {
    click: () => void;
    automationId: string;
    globalPosition: IPoint;
    visibility: boolean;
}
declare class QAAutomationManager {
    protected renderManager: RenderManager;
    protected rootContainer: AXContainer;
    constructor();
    protected getChildById(id: string): IAutomationId;
    protected getListOfAllAutomationIds(): IAutomationId[];
    private createArrayWithAutomationIdObjects;
    private createObjectForAutomation;
    private setAutomationCommands;
    private setGameSpeed;
    private simulateClick;
}

declare class ResourceManager {
    resources: Record<string, any>;
    Texture: typeof Texture;
    getJson(name: string): any;
    getResource(name: string): any;
    getSpineData(name: string): SkeletonData;
    getTexture(name: string): Texture;
    setResources(data: Record<string, any>): void;
    addTextureToCache(texture: Texture, name: string): void;
}

interface ITranslationsResourceData {
    resourceType: 'translations';
}
type TranslationStorage = Record<string, string>;
declare class TranslationManager {
    private _texts;
    get texts(): TranslationStorage;
    addTexts(data: TranslationStorage): void;
    getTranslation(key: string, textParams?: TranslationStorage): string;
    private formatText;
}

type LoadGroup = 'initial' | string;
interface IResourceData {
}
type LoaderResourcesData = ISoundResourceData | ISoundSpriteResourceData | ITranslationsResourceData | IResourceData;
type LoaderResourceData = LoaderResourcesData & {
    metadata?: any;
};
type LoaderResource = {
    name?: string;
    loadGroup?: LoadGroup;
    url: string;
    data?: LoaderResourceData;
};
declare class LoaderManager {
    readonly loader: Loader;
    protected eventEmitter: EventEmitter<AXCoreEvents>;
    protected resourceManager: ResourceManager;
    private resourceOptions;
    constructor();
    addBaseUrl(url: string): void;
    addCacheID(value: string): void;
    addResourceOption(name: string, value: string): void;
    getResourceOptions(): Map<string, string>;
    load(priority: LoadGroup): Promise<void>;
    prepareResources(items: LoaderResource[]): void;
    protected addDefaultResourceOptions(): void;
    protected replaceUrlParam(url: string): string;
    protected modifyResourceData(data: any): any;
    protected emitLoadingEvent(progress: number, group: LoadGroup): void;
}

declare const enum VIBRATION_LENGTH {
    SHORT = 50,
    MEDIUM = 100,
    LONG = 200
}
declare class VibrationManager {
    private _isEnabled;
    get isEnabled(): boolean;
    set isEnabled(value: boolean);
    get isSupported(): boolean;
    vibrate(length?: VIBRATION_LENGTH, loops?: number): boolean;
}

interface IRootContainerLayout extends Omit<IContainerLayout, 'selector'> {
    selector: 'rootContainer';
}
declare class RootContainerComponent extends AXContainer {
    private gameContainer;
    private createdScene;
    private renderManager;
    private displayDataManager;
    createScene(sceneId: string): Promise<any>;
    runScene(sceneID: string): Promise<any>;
    onDisplayDataUpdate(displayData: DisplayDataParams): void;
}

type FullSizeConfig = {
    width?: number;
    height?: number;
};
declare class FullSize extends ViewExtension<IGameComponent, FullSizeConfig> {
    static type: 'fullSize';
    create(): void;
    update(displayDataParams: DisplayDataParams): void;
    private calcScale;
}
type FulLSizeViewExtension = {
    type: typeof FullSize['type'];
    config: FullSizeConfig;
};

type StickToEdgeConfig = {};
declare class StickToEdge extends ViewExtension<IGameComponent, StickToEdgeConfig> {
    static type: 'stickToEdge';
    protected displayDataManager: DisplayDataManager;
    create(): void;
    update(displayData: DisplayDataParams): void;
    private isNeedUpdate;
    private defineSideProperty;
    private defineContentBoxProperty;
}
type StickToEdgeViewExtension = {
    type: (typeof StickToEdge)['type'];
    config: StickToEdgeConfig;
};

type OrientationStateConfig<T = any> = {
    desktop?: T;
    landscape?: T;
    portrait?: T;
    tabLandscape?: T;
    tabPortrait?: T;
};
declare class OrientationState extends ViewExtension<IGameComponent, OrientationStateConfig> {
    static type: 'orientationState';
    create(): void;
    update(displayData: DisplayDataParams): void;
}
type OrientationStateViewExtension<T> = {
    type: typeof OrientationState['type'];
    config: OrientationStateConfig<T>;
};

type PropertyApplier = (component: IGameComponent, name: string, value: any) => boolean;
type HitAreaShape = 'rectangle' | 'circle';
type PointLike = number | {
    x?: number;
    y?: number;
};
interface IHitAreaParams {
    height?: number;
    radius?: number;
    shape: HitAreaShape;
    width?: number;
    x?: number;
    y?: number;
}
type ContentBox = 'global' | 'design';
type BaseGameComponentChangeableParams = Partial<{
    alpha: number;
    visible: boolean;
    renderable: boolean;
    filterArea: Rectangle;
    filters: Filter[];
    x: number;
    y: number;
    rotation: number;
    angle: number;
    zIndex: number;
    mask: Container | MaskData | null;
    hitArea: IHitAreaParams;
    pivot: PointLike;
    position: PointLike;
    scale: PointLike;
    skew: PointLike;
    left: number;
    right: number;
    top: number;
    bottom: number;
    contentBox: ContentBox;
    eventMode: EventMode;
    cursor: Cursor;
}>;
type ViewExtensionFormat<P extends BaseGameComponentChangeableParams = BaseGameComponentChangeableParams> = FulLSizeViewExtension | StickToEdgeViewExtension | OrientationStateViewExtension<P>;
type IBaseGameComponentLayout<P extends BaseGameComponentChangeableParams = BaseGameComponentChangeableParams> = {
    selector: string;
    name?: string;
    automationId?: string;
    template?: string;
    extensions?: ViewExtensionFormat<P>[];
} & P;
type AXCoreLayouts = IAnimatedSpriteLayout | IButtonLayout | IContainerLayout | IGraphicsLayout | INineSlicePlaneLayout | IParticlesEmitterLayout | ISpineLayout | ISpineButtonLayout | ISpriteLayout | ITilingSpriteLayout | IBitmapTextLayout | IHTMLTextLayout | ITextLayout | IRootContainerLayout;

interface ParticleContainerConfig {
    autoResize?: boolean;
    batchSize?: number;
    blendMode?: number;
    maxSize?: number;
    properties?: IParticleProperties;
}
interface IAccelerationMovement {
    type: 'moveAcceleration';
    config: {
        accel: {
            x: number;
            y: number;
        };
        minStart: number;
        maxStart: number;
        rotate?: boolean;
        maxSpeed?: number;
    };
}
interface IAlpha {
    type: 'alpha';
    config: {
        alpha: ValueList<number>;
    };
}
interface IAlphaStatic {
    type: 'alphaStatic';
    config: {
        alpha: number;
    };
}
interface IAnimatedRandom {
    type: 'animatedRandom';
    config: {
        anims: AnimatedParticleArt[];
    };
}
interface IAnimatedSingle {
    type: 'animatedSingle';
    config: {
        anim: AnimatedParticleArt;
    };
}
interface IBlendMode {
    type: 'blendMode';
    /**
     * Blend mode of all particles. This value is a key from
     * [PixiJs's BLEND_MODE enum](https://pixijs.download/release/docs/PIXI.html#BLEND_MODES).
     */
    config: {
        blendMode: string;
    };
}
interface ISpawnBurst {
    type: 'spawnBurst';
    config: {
        spacing: number;
        start: number;
        distance: number;
    };
}
interface IColor {
    type: 'color';
    config: {
        color: ValueList<string>;
    };
}
interface IColorStatic {
    type: 'colorStatic';
    config: {
        color: string;
    };
}
interface IOrderedTexture {
    type: 'textureOrdered';
    config: {
        textures: string[];
    };
}
interface IPathMovement {
    type: 'movePath';
    config: {
        path: string | ((x: number) => number);
        speed: ValueList<number>;
        minMult: number;
    };
}
interface IPointSpawn {
    type: 'spawnPoint';
}
interface IRandomTexture {
    type: 'textureRandom';
    config: {
        textures: string[];
    };
}
interface IRotation {
    type: 'rotation';
    config: {
        minStart: number;
        maxStart: number;
        minSpeed: number;
        maxSpeed: number;
        accel: number;
    };
}
interface IRotationStatic {
    type: 'rotationStatic';
    config: {
        min: number;
        max: number;
    };
}
interface INoRotation {
    type: 'noRotation';
    config: {
        rotation?: number;
    };
}
interface IScale {
    type: 'scale';
    config: {
        scale: ValueList<number>;
        minMult: number;
    };
}
interface IScaleStatic {
    type: 'scaleStatic';
    config: {
        min: number;
        max: number;
    };
}
interface ISpawnShapeRect {
    type: 'rect';
    data: {
        x: number;
        y: number;
        w: number;
        h: number;
    };
}
interface ISpawnShapeTorus {
    type: 'torus';
    data: {
        radius: number;
        x: number;
        y: number;
        innerRadius?: number;
        rotation?: boolean;
    };
}
interface ISpawnShapePoligonalChain {
    type: 'polygonalChain';
    data: {
        x: number;
        y: number;
    }[][];
}
interface ISpawnShape {
    type: 'spawnShape';
    config: ISpawnShapeRect | ISpawnShapeTorus | ISpawnShapePoligonalChain;
}
interface ISingleTexture {
    type: 'textureSingle';
    config: {
        texture: string;
    };
}
interface IMoveSpeed {
    type: 'moveSpeed';
    config: {
        speed: ValueList<number>;
        minMult: number;
    };
}
interface IMoveSpeedStatic {
    type: 'moveSpeedStatic';
    config: {
        min: number;
        max: number;
    };
}
type BehaviourEntryExtended = IAccelerationMovement | IAlpha | IAlphaStatic | IAnimatedRandom | IAnimatedSingle | IBlendMode | ISpawnBurst | IColor | IColorStatic | IOrderedTexture | IPathMovement | IPointSpawn | IRandomTexture | IRotation | IRotationStatic | INoRotation | IScale | IScaleStatic | ISpawnShape | ISingleTexture | IMoveSpeed | IMoveSpeedStatic;
interface EmitterConfigV3Extended extends Omit<EmitterConfigV3, 'behaviors'> {
    behaviors: BehaviourEntryExtended[];
}
interface IParticleEmitterV1Config {
    type: 'v1';
    emitter: EmitterConfigV1;
    assets: string[];
    particleContainer?: ParticleContainerConfig;
}
interface IParticleEmitterV2Config {
    type: 'v2';
    emitter: EmitterConfigV2;
    assets: string[];
    particleContainer?: ParticleContainerConfig;
}
interface IParticleEmitterV3Config {
    type: 'v3';
    emitter: EmitterConfigV3;
    particleContainer?: ParticleContainerConfig;
}
interface IParticleEmitterV3ExtendedConfig {
    type: 'v3extended';
    emitter: EmitterConfigV3Extended;
    particleContainer?: ParticleContainerConfig;
}

type IBaseText = (Container | Sprite) & {
    text: string;
    resolution: number;
};
type TextParams = Record<string, any>;
type TextMaxSize = {
    width?: number;
    height?: number;
};
declare abstract class BaseText<T extends IBaseText> extends AXContainer {
    _textKey: string;
    _textParams: TextParams;
    anchor: ObservablePoint;
    protected _maxSize: TextMaxSize;
    protected _textField: T;
    protected originalText: string;
    protected translationManager: TranslationManager;
    get resolution(): number;
    set resolution(value: number);
    get maxSize(): TextMaxSize;
    set maxSize(value: TextMaxSize);
    get text(): string;
    set text(text: string);
    get textField(): T;
    get textKey(): string;
    set textKey(value: string);
    get textParams(): Record<string, string>;
    set textParams(value: Record<string, string>);
    abstract get blendMode(): number;
    abstract set blendMode(value: number);
    updateText(): void;
    protected resizeText(): void;
    protected abstract getPadding(): number;
}

type BitmapTextChangeableParams = Partial<{
    anchor: PointLike;
    maxSize: {
        width?: number;
        height?: number;
    };
    style: Partial<IBitmapTextStyle>;
    text: string;
    textKey: string;
    textParams: Record<string, string>;
    resolution: number;
    blendMode: number;
}> & BaseGameComponentChangeableParams;
interface IBitmapTextLayout extends IBaseGameComponentLayout<BitmapTextChangeableParams> {
    selector: 'bitmapText';
}
declare class AXBitmapText extends BaseText<BitmapText> {
    static appliers: PropertyApplier[];
    constructor(layout: IBitmapTextLayout);
    get style(): IBitmapTextStyle;
    set style(value: Partial<IBitmapTextStyle>);
    get blendMode(): number;
    set blendMode(value: number);
    getAppliers(): PropertyApplier[];
    updateText(): void;
    protected getPadding(): number;
    private createTextField;
}
declare const applyBitmapTextLayout: (element: AXBitmapText, name: keyof IBitmapTextLayout, value: any) => boolean;

type HtmlStyle = Record<string, object>;
type HTMLTextChangeableParams = Partial<{
    anchor: PointLike;
    htmlStyle: HtmlStyle;
    maxSize: {
        width?: number;
        height?: number;
    };
    style: Partial<IHTMLTextStyle>;
    text: string;
    textKey: string;
    textParams: Record<string, string>;
    resolution: number;
    blendMode: number;
}> & BaseGameComponentChangeableParams;
interface IHTMLTextLayout extends IBaseGameComponentLayout<HTMLTextChangeableParams> {
    selector: 'HTMLText';
}
declare class AXHTMLText extends BaseText<HTMLText> {
    static appliers: PropertyApplier[];
    static defaultStyle: Partial<HTMLTextStyle>;
    private _htmlStyle;
    constructor();
    get htmlStyle(): HtmlStyle;
    set htmlStyle(value: HtmlStyle);
    get style(): HTMLTextStyle;
    set style(value: Partial<IHTMLTextStyle>);
    get blendMode(): number;
    set blendMode(value: number);
    getAppliers(): PropertyApplier[];
    updateText(): void;
    protected getPadding(): number;
    protected updateStylesheet(): void;
    private createTextField;
}
declare const applyHTMLTextLayout: (component: AXHTMLText, name: string, value: any) => boolean;

type TextTransform = 'none' | 'uppercase' | 'lowercase';
interface TextLayoutStyle extends ITextStyle {
    textTransform: TextTransform;
}
type TextChangeableParams = Partial<{
    anchor: PointLike;
    maxSize: {
        width?: number;
        height?: number;
    };
    style: Partial<TextLayoutStyle>;
    text: string;
    textKey: string;
    textParams: Record<string, string>;
    resolution: number;
    blendMode: number;
}> & BaseGameComponentChangeableParams;
interface ITextLayout extends IBaseGameComponentLayout<TextChangeableParams> {
    selector: 'text';
}
declare class AXText extends BaseText<Text> {
    static appliers: PropertyApplier[];
    static defaultStyle: Partial<ITextStyle & {
        textTransform: TextTransform;
    }>;
    private _textTransform;
    constructor();
    get style(): Partial<ITextStyle>;
    set style(value: Partial<ITextStyle>);
    get textTransform(): TextTransform;
    set textTransform(value: TextTransform);
    get blendMode(): number;
    set blendMode(value: number);
    getAppliers(): PropertyApplier[];
    updateText(): void;
    protected createTextField(): void;
    protected getPadding(): number;
    protected transformText(): void;
}
declare const applyTextLayout: (component: AXText, name: string, value: any) => boolean;

type AnimatedSpriteChangeableParams = Partial<{
    autoUpdate: boolean;
    anchor: PointLike;
    animationSpeed: number;
    loop: boolean;
    updateAnchor: boolean;
    defaultAnimation: boolean;
}> & BaseGameComponentChangeableParams;
interface IAnimatedSpriteLayout extends IBaseGameComponentLayout<AnimatedSpriteChangeableParams> {
    selector: "animatedSprite";
    animation?: string;
    sequences: Record<string, string[]>;
}
declare class AXAnimatedSprite extends AnimatedSprite implements IGameComponent {
    static appliers: PropertyApplier[];
    sequences: Record<string, Texture[]>;
    private animationCompleteResolve;
    private loopsCount;
    constructor();
    applyLayout(layout: IAnimatedSpriteLayout): void;
    destroy(options?: IDestroyOptions | boolean): void;
    forceComplete(): void;
    getAppliers(): PropertyApplier[];
    onCompleteInternal(): void;
    onDisplayDataUpdate(displayData: DisplayDataParams): void;
    playAnim(name: string, loop?: boolean): void;
    playMovie(name: string, loopsCount?: number): Promise<any>;
}
declare const applyAnimatedSpriteLayout: (component: AXAnimatedSprite, name: string, value: any) => boolean;

type SpriteChangeableParams = Partial<{
    blendMode: BLEND_MODES;
    roundPixels: boolean;
    width: number;
    height: number;
    tint: number;
    anchor: PointLike;
    img: string;
}> & BaseGameComponentChangeableParams;
interface ISpriteLayout extends IBaseGameComponentLayout<SpriteChangeableParams> {
    selector: 'sprite';
}
declare class AXSprite extends Sprite implements IGameComponent {
    static appliers: PropertyApplier[];
    protected resourceManager: ResourceManager;
    constructor();
    applyLayout(layout: ISpriteLayout): void;
    changeTexture(name: string): void;
    getAppliers(): PropertyApplier[];
    onDisplayDataUpdate(displayData: DisplayDataParams): void;
}
declare const applySpriteLayout: (component: AXSprite, name: string, value: any) => boolean;

interface ButtonEvents extends DisplayObjectEvents {
    buttonOver: [FederatedMouseEvent];
    buttonDown: [FederatedMouseEvent];
    buttonUp: [FederatedMouseEvent];
    buttonUpOutside: [FederatedMouseEvent];
    buttonClick: [FederatedMouseEvent];
    buttonOut: [FederatedMouseEvent];
}
type ButtonState = 'normal' | 'hover' | 'down' | 'disabled';
type ButtonStateTextures = Record<ButtonState, Texture>;
type ButtonChangeableParams = Partial<{
    img: Record<ButtonState, string>;
}> & BaseGameComponentChangeableParams;
interface IButtonLayout extends IBaseGameComponentLayout<ButtonChangeableParams> {
    selector: 'button';
    isActive?: boolean;
    label?: ITextLayout | IBitmapTextLayout | IHTMLTextLayout;
    soundName?: string;
}
declare class AXButton<T extends BaseText<any> = BaseText<any>> extends AXContainer {
    static appliers: PropertyApplier[];
    soundName?: string;
    protected buttonSprite: AXSprite;
    protected isDown: boolean;
    protected isOver: boolean;
    protected soundManager: SoundManager;
    protected renderManager: RenderManager;
    protected stateTextures: ButtonStateTextures;
    protected state: ButtonState;
    private _label;
    private _isActive;
    private _visible;
    constructor();
    get isActive(): boolean;
    set isActive(active: boolean);
    get label(): T;
    set label(value: T);
    getAppliers(): PropertyApplier[];
    setStateTexture(state: ButtonState, texture: Texture): void;
    setStateTextures(stateTextures: Record<ButtonState, Texture>): void;
    virtualClick(): void;
    resetState(): void;
    protected addhandlers(): void;
    protected createButtonSprite(): void;
    protected emitEvent(state: keyof ButtonEvents, event: FederatedMouseEvent): void;
    protected onButtonDown(event: FederatedMouseEvent): void;
    protected onButtonOut(event: FederatedMouseEvent): void;
    protected onButtonOver(event: FederatedMouseEvent): void;
    protected onButtonUp(event: FederatedMouseEvent): void;
    protected onClick(event: FederatedMouseEvent): void;
    protected onUpOutside(event: FederatedMouseEvent): void;
    protected playSound(): void;
    protected updateState(): void;
    protected updateTexture(state: ButtonState): void;
}
declare const applyButtonLayout: (component: AXButton, name: string, value: any) => boolean;

type GraphicsChangeableParams = Partial<{
    blendMode?: BLEND_MODES;
    tint?: number;
    height?: number;
    width?: number;
}> & BaseGameComponentChangeableParams;
type GraphicsShape = 'rect' | 'roundRect' | 'circle' | 'ellipse';
interface IGraphicsLayout extends IBaseGameComponentLayout<GraphicsChangeableParams> {
    selector: 'graphics';
    color?: ColorSource;
    lineStyle?: ILineStyleOptions;
    radius?: number;
    ellipseXRadius?: number;
    ellipseYRadius?: number;
    shape: GraphicsShape;
}
declare class AXGraphics extends Graphics implements IGameComponent {
    static appliers: PropertyApplier[];
    constructor(layout: IGraphicsLayout);
    applyLayout(layout: IGraphicsLayout): void;
    getAppliers(): PropertyApplier[];
    onDisplayDataUpdate(displayData: DisplayDataParams): void;
    private drawLayout;
}
declare const applyGraphicsLayout: (_component: AXGraphics, name: string) => boolean;

type NineSlicePlaneChangeableParams = Partial<{
    vertices: ITypedArray;
    width: number;
    height: number;
    blendMode: BLEND_MODES$1;
    roundPixels: boolean;
    tint: number;
}> & BaseGameComponentChangeableParams;
interface INineSlicePlaneLayout extends IBaseGameComponentLayout<NineSlicePlaneChangeableParams> {
    selector: 'nineSlicePlane';
    img: string;
    leftWidth: number;
    rightWidth: number;
    topHeight: number;
    bottomHeight: number;
    autoResize: boolean;
}
declare class AXNineSlicePlane extends NineSlicePlane implements IGameComponent {
    static appliers: PropertyApplier[];
    protected appliers: PropertyApplier[];
    constructor(layout: INineSlicePlaneLayout);
    applyLayout(layout: INineSlicePlaneLayout): void;
    getAppliers(): PropertyApplier[];
    onDisplayDataUpdate(displayData: DisplayDataParams): void;
}
declare const applyNineSlicePlaneLayout: (element: AXNineSlicePlane, name: string, value: any) => boolean;

type ParticleEmitterChangeableParams = Partial<{
    paused: boolean;
}> & BaseGameComponentChangeableParams;
interface IParticlesEmitterLayout extends IBaseGameComponentLayout<ParticleEmitterChangeableParams> {
    selector: 'particlesEmitter';
    config: IParticleEmitterV1Config | IParticleEmitterV2Config | IParticleEmitterV3Config | IParticleEmitterV3ExtendedConfig;
}
declare class AXParticlesEmitter extends AXContainer {
    static appliers: PropertyApplier[];
    particleContainer: ParticleContainer;
    emitter: Emitter;
    constructor(layout: IParticlesEmitterLayout);
    getAppliers(): PropertyApplier[];
    start(): void;
    stop(): void;
    private init;
}
declare const applyParticlesEmitterLayout: (component: AXParticlesEmitter, name: string, value: any) => boolean;

type SpineChangeableParams = Partial<{
    tintRgb: ArrayLike<number>;
    tint: number;
    autoUpdate: boolean;
    animationSpeed: number;
    skin: string;
}> & BaseGameComponentChangeableParams;
interface ISpineLayout extends IBaseGameComponentLayout<SpineChangeableParams> {
    selector: 'spine';
    animation?: string;
    loop?: boolean;
    spine: string;
}
declare class AXSpine extends Spine implements IGameComponent {
    static appliers: PropertyApplier[];
    static globalTimeScale: number;
    onEvent: (name: string, entry: ITrackEntry) => void;
    loop: boolean;
    private _animationsResolve;
    private _globalTimeScale;
    private _localTimeScale;
    constructor(layout: ISpineLayout);
    get timeScale(): number;
    set timeScale(value: number);
    applyLayout(layout: ISpineLayout): void;
    destroy(options?: any): void;
    forceComplete(): void;
    getAppliers(): PropertyApplier[];
    onDisplayDataUpdate(displayData: DisplayDataParams): void;
    play(name: string, trackIndex?: number, loop?: boolean): void;
    playMovie(name: string, trackIndex?: number, loopsCount?: number): Promise<any>;
    setSkinByName(name: string): void;
    stop(): void;
    update(dt: number): void;
    private addHandlers;
    private onCompleteCheck;
}
declare const applySpineLayout: (component: AXSpine, name: string, value: any) => boolean;

interface ISpineButtonLayout extends IBaseGameComponentLayout<BaseGameComponentChangeableParams> {
    selector: 'spineButton';
    isActive?: boolean;
    spine: ISpineLayout;
    animations: Record<ButtonState, string>;
    soundName?: string;
}
declare class AXSpineButton extends AXContainer {
    static appliers: PropertyApplier[];
    soundName?: string;
    protected _buttonSpine: AXSpine;
    protected _stateAnimations: Record<ButtonState, string>;
    protected soundManager: SoundManager;
    protected renderManager: RenderManager;
    protected isDown: boolean;
    protected isOver: boolean;
    protected currentState: ButtonState;
    protected playStateAnimBlocked: boolean;
    protected _lastAnimationPlayed: string;
    private _isActive;
    constructor();
    get isActive(): boolean;
    set isActive(active: boolean);
    getAppliers(): PropertyApplier[];
    virtualClick(): void;
    createButtonSpine(spineName: string): void;
    get buttonSpine(): AXSpine;
    set buttonSpine(value: AXSpine);
    get stateAnimations(): Record<ButtonState, string>;
    set stateAnimations(value: Record<ButtonState, string>);
    protected addhandlers(): void;
    protected emitEvent(state: keyof ButtonEvents, event: FederatedMouseEvent): void;
    protected onButtonDown(event: FederatedMouseEvent): void;
    protected onButtonOut(event: FederatedMouseEvent): void;
    protected onButtonOver(event: FederatedMouseEvent): void;
    protected onButtonUp(event: FederatedMouseEvent): void;
    protected onClick(event: FederatedMouseEvent): void;
    protected onUpOutside(event: FederatedMouseEvent): void;
    protected playSound(): void;
    protected updateState(): void;
    playStateAnimation(state: ButtonState): void;
}
declare const applySpineButtonLayout: (component: AXSpineButton, name: string, value: any) => boolean;

type TilingSpriteChangeableParams = Partial<{
    uvRespectAnchor: boolean;
    clampMargin: number;
    width: number;
    height: number;
    anchor: PointLike;
    tileScale: PointLike;
    tilePosition: PointLike;
}> & BaseGameComponentChangeableParams;
interface ITilingSpriteLayout extends IBaseGameComponentLayout<TilingSpriteChangeableParams> {
    selector: 'tilingSprite';
    img?: string;
}
declare class AXTilingSprite extends TilingSprite implements IGameComponent {
    static appliers: PropertyApplier[];
    constructor(layout: ITilingSpriteLayout);
    applyLayout(layout: ITilingSpriteLayout): void;
    getAppliers(): PropertyApplier[];
    onDisplayDataUpdate(displayData: DisplayDataParams): void;
}
declare const applyTilingSpriteLayout: (component: AXTilingSprite, name: string, value: any) => boolean;

declare function applyBaseLayout(component: IGameComponent, name: string, value: any): boolean;
declare const applyPointLikeParam: <T extends string>(param: T, component: { [key in T]: ObservablePoint<any>; }, value: PointLike) => void;
declare const applyHitArea: (component: {
    hitArea: IHitArea;
}, params: IHitAreaParams) => void;
declare function applyLayout(component: IGameComponent, layout: IBaseGameComponentLayout): void;

declare const appliers_d_applyBaseLayout: typeof applyBaseLayout;
declare const appliers_d_applyHitArea: typeof applyHitArea;
declare const appliers_d_applyLayout: typeof applyLayout;
declare const appliers_d_applyPointLikeParam: typeof applyPointLikeParam;
declare namespace appliers_d {
  export { appliers_d_applyBaseLayout as applyBaseLayout, appliers_d_applyHitArea as applyHitArea, appliers_d_applyLayout as applyLayout, appliers_d_applyPointLikeParam as applyPointLikeParam };
}

interface IGameComponent extends DisplayObject {
    applyLayout(layout: IBaseGameComponentLayout): void;
    getAppliers(): PropertyApplier[];
    onDisplayDataUpdate(displayData: DisplayDataParams): void;
}
interface IGameComponentConstructor {
    new (layout?: IBaseGameComponentLayout): IGameComponent;
}
declare module '@pixi/display' {
    interface DisplayObject {
        automationId: string;
        left: number;
        right: number;
        top: number;
        bottom: number;
        contentBox: ContentBox;
        extensions: ViewExtension$1<IGameComponent, object>[];
    }
}

interface IInjectable {
}
interface IInjectableConstructor {
    new (): IInjectable;
}

interface IGameAction {
    promise: Promise<any>;
    run(data?: any): void;
    destroy(): void;
}
interface IGameActionConstructor {
    new (): IGameAction;
}

declare const inject: <T>(constructor: IInjectableConstructor) => T;
declare const Injectable: (toInjection?: IInjectableConstructor) => (constructor: IInjectableConstructor) => void;

type ListenerFn<T = unknown> = (event: T) => void;
declare abstract class Mediator<Events extends AXCoreEvents = AXCoreEvents> extends EventEmitterProvider<Events> {
    protected view: IGameComponent;
    private viewListenersMap;
    constructor(view: IGameComponent);
    protected onView(type: string, handler: ListenerFn<any>): void;
    protected offView(type: string, handler?: ListenerFn<any>): void;
    protected removeAllListeners(): void;
    protected abstract initialize(): void;
}
type IMediatorConstructor = new (view: IGameComponent) => Mediator<any>;

type GameComponentOptions = {
    selector: string;
    layout?: IBaseGameComponentLayout;
    mediator?: IMediatorConstructor;
};
declare const createComponent: <T extends IGameComponent, G extends IBaseGameComponentLayout>(layout: G) => T;
declare const createComponentFromId: <T extends IGameComponent>(id: string) => T;
declare const GameComponent: ({ selector, layout, mediator, }: GameComponentOptions) => (constructor: IGameComponentConstructor) => void;

declare const runAction: (action: IGameActionConstructor, data?: any) => Promise<any>;
declare class GameAction<Events extends AXCoreEvents, T = any> extends EventEmitterProvider<Events> implements IGameAction {
    promise: Promise<T>;
    private resolvePromise;
    private rejectPromise;
    constructor();
    run(_payload: any): void;
    destroy(): void;
    protected resolve(data?: T): void;
    protected reject(data?: T): void;
}
declare const InjectableAction: (toInjection?: IGameActionConstructor) => (constructor: IGameActionConstructor) => void;
declare const bindActionToEvent: <Events extends AXCoreEvents>(eventName: keyof Events, asPromise?: boolean) => (constructor: IGameActionConstructor) => void;

declare abstract class ViewExtension<V extends IGameComponent, C extends object> {
    protected component: V;
    protected config: C;
    static type: string;
    constructor(component: V, config: C);
    abstract create(): void;
    abstract update(displayDataParams: DisplayDataParams): void;
}
interface IViewExtensionConstructor<V extends IGameComponent, C extends object> {
    type: string;
    new (component: V, config: C): ViewExtension<V, C>;
}
declare const viewExtensions: {
    _queue: Map<string, IViewExtensionConstructor<IGameComponent, any>>;
    add(extension: IViewExtensionConstructor<IGameComponent, any>): void;
    remove(extension: IViewExtensionConstructor<IGameComponent, any>): void;
    get(type: string): IViewExtensionConstructor<IGameComponent, any>;
};

interface ISettings {
    LOGGER: boolean;
    WINDOW_DEBUG: boolean;
    COMMANDS: boolean;
}
declare const settings: ISettings;

declare abstract class AXApplication {
    protected renderManager: RenderManager;
    protected constructor(container: HTMLElement, options?: IRendererSetupOptions);
    protected setup(container: HTMLElement, options?: IRendererSetupOptions): Promise<any>;
    protected registerComponents(components: IGameComponentConstructor[]): void;
    protected registerActions(actions: IGameActionConstructor[]): void;
    protected registerLayoutTemplates(templates: Record<string, object>): void;
    protected abstract init(): void;
}

declare const loadTranslations: LoaderParser<Record<string, string>, ITranslationsResourceData, any>;

declare const loadSounds: LoaderParser<Record<string, string>, (ISoundSpriteResourceData | ISoundResourceData), any>;

declare global {
    interface Window {
        PIXI: typeof PIXI;
        gsap: typeof gsap;
        automationCommands: any;
        __PIXI_APP__: {
            stage: IDisplayObjectExtended;
            renderer: IRenderer;
            view: ICanvas$1;
        };
    }
}

export { AXAnimatedSprite, AXApplication, AXBitmapText, AXButton, AXContainer, type AXCoreEvents, type AXCoreLayouts, AXGraphics, AXHTMLText, AXNineSlicePlane, AXParticlesEmitter, AXSpine, AXSpineButton, AXSprite, AXText, AXTilingSprite, type AnimatedSpriteChangeableParams, type BaseGameComponentChangeableParams, BaseText, type BitmapTextChangeableParams, type ButtonChangeableParams, type ButtonEvents, type ButtonState, type ButtonStateTextures, type ContainerChangeableParams, type ContentBox, type DeviceOrientation, type DeviceType, DisplayDataManager, type DisplayDataParams, type EmitterConfigV3Extended, EventEmitter, EventEmitterProvider, type EventHandler, type FulLSizeViewExtension, FullSize, GameAction, GameComponent, type GraphicsChangeableParams, type GraphicsShape, type HTMLTextChangeableParams, type HitAreaShape, type HtmlStyle, type IAnimatedSpriteLayout, type IAutomationId, type IBaseGameComponentLayout, type IBitmapTextLayout, type IButtonLayout, type IContainerLayout, type IGameAction, type IGameActionConstructor, type IGameComponent, type IGameComponentConstructor, type IGraphicsLayout, type IHTMLTextLayout, type IHitAreaParams, type IInjectable, type IInjectableConstructor, type INineSlicePlaneLayout, type IParticleEmitterV1Config, type IParticleEmitterV2Config, type IParticleEmitterV3Config, type IParticleEmitterV3ExtendedConfig, type IParticlesEmitterLayout, type IRendererSetupOptions, type IResourceData, type IRootContainerLayout, type ISettings, type ISoundResourceData, type ISoundResourceOptions, type ISoundSpriteResourceData, type ISpineButtonLayout, type ISpineLayout, type ISpriteLayout, type ITextLayout, type ITilingSpriteLayout, type ITranslationsResourceData, Injectable, InjectableAction, type LoadGroup, LoaderManager, type LoaderResource, type LoaderResourceData, type LoaderResourcesData, Mediator, type NineSlicePlaneChangeableParams, OrientationState, type OrientationStateType, type OrientationStateViewExtension, type ParticleContainerConfig, type ParticleEmitterChangeableParams, type PointLike, type PropertyApplier, QAAutomationManager, RenderManager, ResourceManager, RootContainerComponent, Sound, type SoundGroup, SoundManager, type SpineChangeableParams, type SpriteChangeableParams, StickToEdge, type StickToEdgeConfig, type StickToEdgeViewExtension, type TextChangeableParams, type TextMaxSize, type TextParams, type TextTransform, type TilingSpriteChangeableParams, TranslationManager, VIBRATION_LENGTH, VibrationManager, ViewExtension, type ViewExtensionFormat, applyAnimatedSpriteLayout, applyBitmapTextLayout, applyButtonLayout, applyContainerLayout, applyGraphicsLayout, applyHTMLTextLayout, applyNineSlicePlaneLayout, applyParticlesEmitterLayout, applySpineButtonLayout, applySpineLayout, applySpriteLayout, applyTextLayout, applyTilingSpriteLayout, bindActionToEvent, createComponent, createComponentFromId, inject, loadSounds, loadTranslations, runAction, settings, index_d as utils, viewExtensions, appliers_d as viewUtils };
