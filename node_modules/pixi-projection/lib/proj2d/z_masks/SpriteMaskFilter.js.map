{"version":3,"file":"SpriteMaskFilter.js","sources":["../../../src/proj2d/z_masks/SpriteMaskFilter.ts"],"sourcesContent":["import { Sprite } from '@pixi/sprite';\r\nimport { Matrix2d } from '../Matrix2d';\r\nimport { Filter, FilterSystem, RenderTexture, TextureMatrix } from '@pixi/core';\r\nimport { Projection2d } from '../Projection2d';\r\n\r\nconst spriteMaskVert = `\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 otherMatrix;\r\n\r\nvarying vec3 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\ngl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\nvTextureCoord = aTextureCoord;\r\nvMaskCoord = otherMatrix * vec3( aTextureCoord, 1.0);\r\n}\r\n`;\r\nconst spriteMaskFrag = `\r\nvarying vec3 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mask;\r\nuniform float alpha;\r\nuniform vec4 maskClamp;\r\n\r\nvoid main(void)\r\n{\r\nvec2 uv = vMaskCoord.xy / vMaskCoord.z;\r\n\r\nfloat clip = step(3.5,\r\n    step(maskClamp.x, uv.x) +\r\n    step(maskClamp.y, uv.y) +\r\n    step(uv.x, maskClamp.z) +\r\n    step(uv.y, maskClamp.w));\r\n\r\nvec4 original = texture2D(uSampler, vTextureCoord);\r\nvec4 masky = texture2D(mask, uv);\r\n\r\noriginal *= (masky.r * masky.a * alpha * clip);\r\n\r\ngl_FragColor = original;\r\n}\r\n`;\r\n\r\nconst tempMat = new Matrix2d();\r\n\r\nexport class SpriteMaskFilter2d extends Filter\r\n{\r\n    constructor(sprite: Sprite)\r\n    {\r\n        super(spriteMaskVert, spriteMaskFrag);\r\n\r\n        sprite.renderable = false;\r\n\r\n        this.maskSprite = sprite;\r\n    }\r\n\r\n    maskSprite: Sprite;\r\n    maskMatrix = new Matrix2d();\r\n\r\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture,\r\n        clearMode?: number): void\r\n    {\r\n        const maskSprite = this.maskSprite;\r\n        const tex = this.maskSprite.texture;\r\n\r\n        if (!tex.valid)\r\n        {\r\n            return;\r\n        }\r\n        if (!tex.uvMatrix)\r\n        {\r\n            // margin = 0.0, let it bleed a bit, shader code becomes easier\r\n            // assuming that atlas textures were made with 1-pixel padding\r\n            tex.uvMatrix = new TextureMatrix(tex, 0.0);\r\n        }\r\n        tex.uvMatrix.update();\r\n\r\n        this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0.0 : 1.0;\r\n        this.uniforms.mask = maskSprite.texture;\r\n        this.uniforms.otherMatrix = SpriteMaskFilter2d.calculateSpriteMatrix(input, this.maskMatrix, maskSprite)\r\n            .prepend(tex.uvMatrix.mapCoord);\r\n        this.uniforms.alpha = maskSprite.worldAlpha;\r\n        this.uniforms.maskClamp = tex.uvMatrix.uClampFrame;\r\n\r\n        filterManager.applyFilter(this, input, output, clearMode);\r\n    }\r\n\r\n    static calculateSpriteMatrix(input: RenderTexture, mappedMatrix: Matrix2d, sprite: Sprite): Matrix2d\r\n    {\r\n        const proj = (sprite as any).proj as Projection2d;\r\n\r\n        const filterArea = (input as any).filterFrame;\r\n\r\n        // eslint-disable-next-line max-len\r\n        const worldTransform = proj && !proj._affine ? proj.world.copyTo2dOr3d(tempMat) : tempMat.copyFrom(sprite.transform.worldTransform);\r\n        const texture = sprite.texture.orig;\r\n\r\n        mappedMatrix.set(input.width, 0, 0, input.height, filterArea.x, filterArea.y);\r\n        worldTransform.invert();\r\n        mappedMatrix.setToMult(worldTransform, mappedMatrix);\r\n        mappedMatrix.scaleAndTranslate(1.0 / texture.width, 1.0 / texture.height,\r\n            sprite.anchor.x, sprite.anchor.y);\r\n\r\n        return mappedMatrix;\r\n    }\r\n}\r\n"],"names":["Matrix2d","Filter","TextureMatrix"],"mappings":";;;;;AAKA,MAAM,cAAiB,GAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA,CAAA;AAkBvB,MAAM,cAAiB,GAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAA,CAAA;AA4BvB,MAAM,OAAA,GAAU,IAAIA,iBAAS,EAAA,CAAA;AAEtB,MAAM,2BAA2BC,WACxC,CAAA;AAAA,EACI,YAAY,MACZ,EAAA;AACI,IAAA,KAAA,CAAM,gBAAgB,cAAc,CAAA,CAAA;AAQxC,IAAA,IAAA,CAAA,UAAA,GAAa,IAAID,iBAAS,EAAA,CAAA;AANtB,IAAA,MAAA,CAAO,UAAa,GAAA,KAAA,CAAA;AAEpB,IAAA,IAAA,CAAK,UAAa,GAAA,MAAA,CAAA;AAAA,GACtB;AAAA,EAKA,KAAM,CAAA,aAAA,EAA6B,KAAsB,EAAA,MAAA,EACrD,SACJ,EAAA;AACI,IAAA,MAAM,aAAa,IAAK,CAAA,UAAA,CAAA;AACxB,IAAM,MAAA,GAAA,GAAM,KAAK,UAAW,CAAA,OAAA,CAAA;AAE5B,IAAI,IAAA,CAAC,IAAI,KACT,EAAA;AACI,MAAA,OAAA;AAAA,KACJ;AACA,IAAI,IAAA,CAAC,IAAI,QACT,EAAA;AAGI,MAAA,GAAA,CAAI,QAAW,GAAA,IAAIE,kBAAc,CAAA,GAAA,EAAK,CAAG,CAAA,CAAA;AAAA,KAC7C;AACA,IAAA,GAAA,CAAI,SAAS,MAAO,EAAA,CAAA;AAEpB,IAAA,IAAA,CAAK,QAAS,CAAA,QAAA,GAAW,GAAI,CAAA,WAAA,CAAY,YAAY,CAAM,GAAA,CAAA,CAAA;AAC3D,IAAK,IAAA,CAAA,QAAA,CAAS,OAAO,UAAW,CAAA,OAAA,CAAA;AAChC,IAAA,IAAA,CAAK,QAAS,CAAA,WAAA,GAAc,kBAAmB,CAAA,qBAAA,CAAsB,KAAO,EAAA,IAAA,CAAK,UAAY,EAAA,UAAU,CAClG,CAAA,OAAA,CAAQ,GAAI,CAAA,QAAA,CAAS,QAAQ,CAAA,CAAA;AAClC,IAAK,IAAA,CAAA,QAAA,CAAS,QAAQ,UAAW,CAAA,UAAA,CAAA;AACjC,IAAK,IAAA,CAAA,QAAA,CAAS,SAAY,GAAA,GAAA,CAAI,QAAS,CAAA,WAAA,CAAA;AAEvC,IAAA,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;AAAA,GAC5D;AAAA,EAEA,OAAO,qBAAA,CAAsB,KAAsB,EAAA,YAAA,EAAwB,MAC3E,EAAA;AACI,IAAA,MAAM,OAAQ,MAAe,CAAA,IAAA,CAAA;AAE7B,IAAA,MAAM,aAAc,KAAc,CAAA,WAAA,CAAA;AAGlC,IAAA,MAAM,cAAiB,GAAA,IAAA,IAAQ,CAAC,IAAA,CAAK,UAAU,IAAK,CAAA,KAAA,CAAM,YAAa,CAAA,OAAO,CAAI,GAAA,OAAA,CAAQ,QAAS,CAAA,MAAA,CAAO,UAAU,cAAc,CAAA,CAAA;AAClI,IAAM,MAAA,OAAA,GAAU,OAAO,OAAQ,CAAA,IAAA,CAAA;AAE/B,IAAa,YAAA,CAAA,GAAA,CAAI,KAAM,CAAA,KAAA,EAAO,CAAG,EAAA,CAAA,EAAG,MAAM,MAAQ,EAAA,UAAA,CAAW,CAAG,EAAA,UAAA,CAAW,CAAC,CAAA,CAAA;AAC5E,IAAA,cAAA,CAAe,MAAO,EAAA,CAAA;AACtB,IAAa,YAAA,CAAA,SAAA,CAAU,gBAAgB,YAAY,CAAA,CAAA;AACnD,IAAa,YAAA,CAAA,iBAAA;AAAA,MAAkB,IAAM,OAAQ,CAAA,KAAA;AAAA,MAAO,IAAM,OAAQ,CAAA,MAAA;AAAA,MAC9D,OAAO,MAAO,CAAA,CAAA;AAAA,MAAG,OAAO,MAAO,CAAA,CAAA;AAAA,KAAC,CAAA;AAEpC,IAAO,OAAA,YAAA,CAAA;AAAA,GACX;AACJ;;;;"}