import { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';
import { Program } from '@pixi/core';
import { Projection2d } from '../Projection2d.mjs';
import '../../base/index.mjs';
import { container2dToLocal } from '../Container2d.mjs';
import { TRANSFORM_STEP } from '../../base/AbstractProjection.mjs';

class Mesh2d extends Mesh {
  constructor(geometry, shader, state, drawMode) {
    super(geometry, shader, state, drawMode);
    this.vertexData2d = null;
    this.proj = new Projection2d(this.transform);
  }
  calculateVertices() {
    if (this.proj._affine) {
      this.vertexData2d = null;
      super.calculateVertices();
      return;
    }
    const geometry = this.geometry;
    const vertices = geometry.buffers[0].data;
    const thisAny = this;
    if (geometry.vertexDirtyId === thisAny.vertexDirty && thisAny._transformID === thisAny.transform._worldID) {
      return;
    }
    thisAny._transformID = thisAny.transform._worldID;
    if (thisAny.vertexData.length !== vertices.length) {
      thisAny.vertexData = new Float32Array(vertices.length);
    }
    if (!this.vertexData2d || this.vertexData2d.length !== vertices.length * 3 / 2) {
      this.vertexData2d = new Float32Array(vertices.length * 3);
    }
    const wt = this.proj.world.mat3;
    const vertexData2d = this.vertexData2d;
    const vertexData = thisAny.vertexData;
    for (let i = 0; i < vertexData.length / 2; i++) {
      const x = vertices[i * 2];
      const y = vertices[i * 2 + 1];
      const xx = wt[0] * x + wt[3] * y + wt[6];
      const yy = wt[1] * x + wt[4] * y + wt[7];
      const ww = wt[2] * x + wt[5] * y + wt[8];
      vertexData2d[i * 3] = xx;
      vertexData2d[i * 3 + 1] = yy;
      vertexData2d[i * 3 + 2] = ww;
      vertexData[i * 2] = xx / ww;
      vertexData[i * 2 + 1] = yy / ww;
    }
    thisAny.vertexDirty = geometry.vertexDirtyId;
  }
  _renderDefault(renderer) {
    const shader = this.shader;
    shader.alpha = this.worldAlpha;
    if (shader.update) {
      shader.update();
    }
    renderer.batch.flush();
    if (shader.program.uniformData?.translationMatrix) {
      shader.uniforms.translationMatrix = this.worldTransform.toArray(true);
    }
    renderer.shader.bind(shader, false);
    renderer.state.set(this.state);
    renderer.geometry.bind(this.geometry, shader);
    renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
  }
  toLocal(position, from, point, skipUpdate, step = TRANSFORM_STEP.ALL) {
    return container2dToLocal.call(this, position, from, point, skipUpdate, step);
  }
  get worldTransform() {
    return this.proj.affine ? this.transform.worldTransform : this.proj.world;
  }
}
Mesh2d.defaultVertexShader = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
gl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);
gl_Position.z = 0.0;

vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
Mesh2d.defaultFragmentShader = `
varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}`;
class SimpleMesh2d extends Mesh2d {
  constructor(texture, vertices, uvs, indices, drawMode) {
    super(
      new MeshGeometry(vertices, uvs, indices),
      new MeshMaterial(texture, {
        program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),
        pluginName: "batch2d"
      }),
      null,
      drawMode
    );
    this.autoUpdate = true;
    this.geometry.getBuffer("aVertexPosition").static = false;
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  _render(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    super._render(renderer);
  }
}

export { Mesh2d, SimpleMesh2d };
//# sourceMappingURL=Mesh2d.mjs.map
