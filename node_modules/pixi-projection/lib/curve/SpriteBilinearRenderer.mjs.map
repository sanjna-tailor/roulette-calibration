{"version":3,"file":"SpriteBilinearRenderer.mjs","sources":["../../src/curve/SpriteBilinearRenderer.ts"],"sourcesContent":["import { BatchShaderGenerator, Buffer, Color, ExtensionType, Geometry, Renderer, ViewableBuffer } from '@pixi/core';\r\nimport { TYPES } from '@pixi/constants';\r\nimport { Sprite } from '@pixi/sprite';\r\nimport { Sprite2s } from './sprites/Sprite2s';\r\nimport { Matrix } from '@pixi/math';\r\nimport { UniformBatchRenderer } from '../base';\r\n\r\nconst shaderVert = `precision highp float;\r\nattribute vec2 aVertexPosition;\r\nattribute vec3 aTrans1;\r\nattribute vec3 aTrans2;\r\nattribute vec2 aSamplerSize;\r\nattribute vec4 aFrame;\r\nattribute vec4 aColor;\r\nattribute float aTextureId;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\n\r\nvarying vec2 vertexPosition;\r\nvarying vec3 vTrans1;\r\nvarying vec3 vTrans2;\r\nvarying vec2 vSamplerSize;\r\nvarying vec4 vFrame;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\n\r\nvoid main(void){\r\ngl_Position.xyw = projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0);\r\ngl_Position.z = 0.0;\r\n\r\nvertexPosition = aVertexPosition;\r\nvTrans1 = aTrans1;\r\nvTrans2 = aTrans2;\r\nvTextureId = aTextureId;\r\nvColor = aColor;\r\nvSamplerSize = aSamplerSize;\r\nvFrame = aFrame;\r\n}\r\n`;\r\n\r\nconst shaderFrag = `precision highp float;\r\nvarying vec2 vertexPosition;\r\nvarying vec3 vTrans1;\r\nvarying vec3 vTrans2;\r\nvarying vec2 vSamplerSize;\r\nvarying vec4 vFrame;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\n\r\nuniform sampler2D uSamplers[%count%];\r\nuniform vec4 distortion;\r\n\r\nvoid main(void){\r\nvec2 surface;\r\nvec2 surface2;\r\n\r\nfloat vx = vertexPosition.x;\r\nfloat vy = vertexPosition.y;\r\nfloat dx = distortion.x;\r\nfloat dy = distortion.y;\r\nfloat revx = distortion.z;\r\nfloat revy = distortion.w;\r\n\r\nif (distortion.x == 0.0) {\r\nsurface.x = vx;\r\nsurface.y = vy / (1.0 + dy * vx);\r\nsurface2 = surface;\r\n} else\r\nif (distortion.y == 0.0) {\r\nsurface.y = vy;\r\nsurface.x = vx / (1.0 + dx * vy);\r\nsurface2 = surface;\r\n} else {\r\nfloat c = vy * dx - vx * dy;\r\nfloat b = (c + 1.0) * 0.5;\r\nfloat b2 = (-c + 1.0) * 0.5;\r\nfloat d = b * b + vx * dy;\r\nif (d < -0.00001) {\r\n    discard;\r\n}\r\nd = sqrt(max(d, 0.0));\r\nsurface.x = (- b + d) * revy;\r\nsurface2.x = (- b - d) * revy;\r\nsurface.y = (- b2 + d) * revx;\r\nsurface2.y = (- b2 - d) * revx;\r\n}\r\n\r\nvec2 uv;\r\nuv.x = vTrans1.x * surface.x + vTrans1.y * surface.y + vTrans1.z;\r\nuv.y = vTrans2.x * surface.x + vTrans2.y * surface.y + vTrans2.z;\r\n\r\nvec2 pixels = uv * vSamplerSize;\r\n\r\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\r\npixels.y < vFrame.y || pixels.y > vFrame.w) {\r\nuv.x = vTrans1.x * surface2.x + vTrans1.y * surface2.y + vTrans1.z;\r\nuv.y = vTrans2.x * surface2.x + vTrans2.y * surface2.y + vTrans2.z;\r\npixels = uv * vSamplerSize;\r\n\r\nif (pixels.x < vFrame.x || pixels.x > vFrame.z ||\r\n   pixels.y < vFrame.y || pixels.y > vFrame.w) {\r\n   discard;\r\n}\r\n}\r\n\r\nvec4 edge;\r\nedge.xy = clamp(pixels - vFrame.xy + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\r\nedge.zw = clamp(vFrame.zw - pixels + 0.5, vec2(0.0, 0.0), vec2(1.0, 1.0));\r\n\r\nfloat alpha = 1.0; //edge.x * edge.y * edge.z * edge.w;\r\nvec4 rColor = vColor * alpha;\r\n\r\nfloat textureId = floor(vTextureId+0.5);\r\nvec2 vTextureCoord = uv;\r\nvec4 color;\r\n%forloop%\r\ngl_FragColor = color * rColor;\r\n}`;\r\n\r\nexport class BatchBilinearGeometry extends Geometry\r\n{\r\n    _buffer: Buffer;\r\n    _indexBuffer : Buffer;\r\n\r\n    constructor(_static = false)\r\n    {\r\n        super();\r\n\r\n        this._buffer = new Buffer(null, _static, false);\r\n\r\n        this._indexBuffer = new Buffer(null, _static, true);\r\n\r\n        this.addAttribute('aVertexPosition', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aTrans1', this._buffer, 3, false, TYPES.FLOAT)\r\n            .addAttribute('aTrans2', this._buffer, 3, false, TYPES.FLOAT)\r\n            .addAttribute('aSamplerSize', this._buffer, 2, false, TYPES.FLOAT)\r\n            .addAttribute('aFrame', this._buffer, 4, false, TYPES.FLOAT)\r\n            .addAttribute('aColor', this._buffer, 4, true, TYPES.UNSIGNED_BYTE)\r\n            .addAttribute('aTextureId', this._buffer, 1, true, TYPES.FLOAT)\r\n            .addIndex(this._indexBuffer);\r\n    }\r\n}\r\n\r\nexport class BatchBilinearRenderer extends UniformBatchRenderer\r\n{\r\n    constructor(renderer: Renderer)\r\n    {\r\n        super(renderer);\r\n        this.vertexSize = 16;\r\n        this.geometryClass = BatchBilinearGeometry;\r\n    }\r\n\r\n    static extension = {\r\n        name: 'batch_bilinear',\r\n        type: ExtensionType.RendererPlugin\r\n    };\r\n\r\n    setShaderGenerator()\r\n    {\r\n        this.shaderGenerator = new BatchShaderGenerator(\r\n            shaderVert,\r\n            shaderFrag\r\n        );\r\n    }\r\n\r\n    defUniforms = {\r\n        translationMatrix: new Matrix(),\r\n        distortion: new Float32Array([0, 0, Infinity, Infinity])\r\n    };\r\n    size = 1000;\r\n    forceMaxTextures = 1;\r\n\r\n    getUniforms(sprite: Sprite)\r\n    {\r\n        const { proj } = sprite as Sprite2s;\r\n\r\n        if (proj.surface !== null)\r\n        {\r\n            return proj.uniforms;\r\n        }\r\n        if (proj._activeProjection !== null)\r\n        {\r\n            return proj._activeProjection.uniforms;\r\n        }\r\n\r\n        return this.defUniforms;\r\n    }\r\n\r\n    // eslint-disable-next-line max-len\r\n    packInterleavedGeometry(element: any, attributeBuffer: ViewableBuffer, indexBuffer: Uint16Array, aIndex: number, iIndex: number)\r\n    {\r\n        const {\r\n            uint32View,\r\n            float32View,\r\n        } = attributeBuffer;\r\n        const p = aIndex / this.vertexSize;\r\n        const indices = element.indices;\r\n        const vertexData = element.vertexData;\r\n        const tex = element._texture;\r\n        const frame = tex._frame;\r\n        const aTrans = element.aTrans;\r\n        const { _batchLocation, realWidth, realHeight, resolution } = element._texture.baseTexture;\r\n\r\n        const alpha = Math.min(element.worldAlpha, 1.0);\r\n        const argb = Color.shared\r\n            .setValue(element._tintRGB)\r\n            .toPremultiplied(alpha);\r\n\r\n        for (let i = 0; i < vertexData.length; i += 2)\r\n        {\r\n            float32View[aIndex] = vertexData[i];\r\n            float32View[aIndex + 1] = vertexData[i + 1];\r\n\r\n            float32View[aIndex + 2] = aTrans.a;\r\n            float32View[aIndex + 3] = aTrans.c;\r\n            float32View[aIndex + 4] = aTrans.tx;\r\n            float32View[aIndex + 5] = aTrans.b;\r\n            float32View[aIndex + 6] = aTrans.d;\r\n            float32View[aIndex + 7] = aTrans.ty;\r\n\r\n            float32View[aIndex + 8] = realWidth;\r\n            float32View[aIndex + 9] = realHeight;\r\n            float32View[aIndex + 10] = frame.x * resolution;\r\n            float32View[aIndex + 11] = frame.y * resolution;\r\n            float32View[aIndex + 12] = (frame.x + frame.width) * resolution;\r\n            float32View[aIndex + 13] = (frame.y + frame.height) * resolution;\r\n\r\n            uint32View[aIndex + 14] = argb;\r\n            float32View[aIndex + 15] = _batchLocation;\r\n            aIndex += 16;\r\n        }\r\n\r\n        for (let i = 0; i < indices.length; i++)\r\n        {\r\n            indexBuffer[iIndex++] = p + indices[i];\r\n        }\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}