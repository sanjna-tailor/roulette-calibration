import { Projection3d } from './Projection3d.mjs';
import { Container } from '@pixi/display';
import '../base/index.mjs';
import { TRANSFORM_STEP } from '../base/AbstractProjection.mjs';

function container3dWorldTransform() {
  return this.proj.affine ? this.transform.worldTransform : this.proj.world;
}
class Container3d extends Container {
  constructor() {
    super();
    this.proj = new Projection3d(this.transform);
  }
  isFrontFace(forceUpdate = false) {
    if (forceUpdate) {
      this._recursivePostUpdateTransform();
      this.displayObjectUpdateTransform();
    }
    const mat = this.proj.world.mat4;
    const dx1 = mat[0] * mat[15] - mat[3] * mat[12];
    const dy1 = mat[1] * mat[15] - mat[3] * mat[13];
    const dx2 = mat[4] * mat[15] - mat[7] * mat[12];
    const dy2 = mat[5] * mat[15] - mat[7] * mat[13];
    return dx1 * dy2 - dx2 * dy1 > 0;
  }
  /**
   * returns depth from 0 to 1
   *
   * @param {boolean} forceUpdate whether to force matrix updates
   * @returns {number} depth
   */
  getDepth(forceUpdate = false) {
    if (forceUpdate) {
      this._recursivePostUpdateTransform();
      this.displayObjectUpdateTransform();
    }
    const mat4 = this.proj.world.mat4;
    return mat4[14] / mat4[15];
  }
  toLocal(position, from, point, skipUpdate, step = TRANSFORM_STEP.ALL) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    if (!skipUpdate) {
      this._recursivePostUpdateTransform();
    }
    if (step === TRANSFORM_STEP.ALL) {
      if (!skipUpdate) {
        this.displayObjectUpdateTransform();
      }
      if (this.proj.affine) {
        return this.transform.worldTransform.applyInverse(position, point);
      }
      return this.proj.world.applyInverse(position, point);
    }
    if (this.parent) {
      point = this.parent.worldTransform.applyInverse(position, point);
    } else {
      point.x = position.x;
      point.y = position.y;
      point.z = position.z;
    }
    if (step === TRANSFORM_STEP.NONE) {
      return point;
    }
    point = this.transform.localTransform.applyInverse(point, point);
    if (step === TRANSFORM_STEP.PROJ && this.proj.cameraMode) {
      point = this.proj.cameraMatrix.applyInverse(point, point);
    }
    return point;
  }
  get worldTransform() {
    return this.proj.affine ? this.transform.worldTransform : this.proj.world;
  }
  get position3d() {
    return this.proj.position;
  }
  set position3d(value) {
    this.proj.position.copyFrom(value);
  }
  get scale3d() {
    return this.proj.scale;
  }
  set scale3d(value) {
    this.proj.scale.copyFrom(value);
  }
  get euler() {
    return this.proj.euler;
  }
  set euler(value) {
    this.proj.euler.copyFrom(value);
  }
  get pivot3d() {
    return this.proj.pivot;
  }
  set pivot3d(value) {
    this.proj.pivot.copyFrom(value);
  }
}
const container3dToLocal = Container3d.prototype.toLocal;
const container3dGetDepth = Container3d.prototype.getDepth;
const container3dIsFrontFace = Container3d.prototype.isFrontFace;

export { Container3d, container3dGetDepth, container3dIsFrontFace, container3dToLocal, container3dWorldTransform };
//# sourceMappingURL=Container3d.mjs.map
