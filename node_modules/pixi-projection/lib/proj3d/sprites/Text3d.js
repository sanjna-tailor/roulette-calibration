'use strict';

var text = require('@pixi/text');
var Projection3d = require('../Projection3d.js');
var Container3d = require('../Container3d.js');
require('../../base/index.js');
var Sprite3d = require('./Sprite3d.js');
var AbstractProjection = require('../../base/AbstractProjection.js');

class Text3d extends text.Text {
  constructor(text, style, canvas) {
    super(text, style, canvas);
    this.vertexData2d = null;
    this.proj = new Projection3d.Projection3d(this.transform);
    this.pluginName = "batch2d";
  }
  get worldTransform() {
    return this.proj.affine ? this.transform.worldTransform : this.proj.world;
  }
  toLocal(position, from, point, skipUpdate, step = AbstractProjection.TRANSFORM_STEP.ALL) {
    return Container3d.container3dToLocal.call(this, position, from, point, skipUpdate, step);
  }
  isFrontFace(forceUpdate) {
    return Container3d.container3dIsFrontFace.call(this, forceUpdate);
  }
  getDepth(forceUpdate) {
    return Container3d.container3dGetDepth.call(this, forceUpdate);
  }
  get position3d() {
    return this.proj.position;
  }
  set position3d(value) {
    this.proj.position.copyFrom(value);
  }
  get scale3d() {
    return this.proj.scale;
  }
  set scale3d(value) {
    this.proj.scale.copyFrom(value);
  }
  get euler() {
    return this.proj.euler;
  }
  set euler(value) {
    this.proj.euler.copyFrom(value);
  }
  get pivot3d() {
    return this.proj.pivot;
  }
  set pivot3d(value) {
    this.proj.pivot.copyFrom(value);
  }
}
Text3d.prototype.calculateVertices = Sprite3d.Sprite3d.prototype.calculateVertices;
Text3d.prototype.calculateTrimmedVertices = Sprite3d.Sprite3d.prototype.calculateTrimmedVertices;
Text3d.prototype._calculateBounds = Sprite3d.Sprite3d.prototype._calculateBounds;
Text3d.prototype.containsPoint = Sprite3d.Sprite3d.prototype.containsPoint;
Text3d.prototype._render = Sprite3d.Sprite3d.prototype._render;

exports.Text3d = Text3d;
//# sourceMappingURL=Text3d.js.map
