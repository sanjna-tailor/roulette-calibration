import { Text } from '@pixi/text';
import { Projection3d } from '../Projection3d.mjs';
import { container3dToLocal, container3dIsFrontFace, container3dGetDepth } from '../Container3d.mjs';
import '../../base/index.mjs';
import { Sprite3d } from './Sprite3d.mjs';
import { TRANSFORM_STEP } from '../../base/AbstractProjection.mjs';

class Text3d extends Text {
  constructor(text, style, canvas) {
    super(text, style, canvas);
    this.vertexData2d = null;
    this.proj = new Projection3d(this.transform);
    this.pluginName = "batch2d";
  }
  get worldTransform() {
    return this.proj.affine ? this.transform.worldTransform : this.proj.world;
  }
  toLocal(position, from, point, skipUpdate, step = TRANSFORM_STEP.ALL) {
    return container3dToLocal.call(this, position, from, point, skipUpdate, step);
  }
  isFrontFace(forceUpdate) {
    return container3dIsFrontFace.call(this, forceUpdate);
  }
  getDepth(forceUpdate) {
    return container3dGetDepth.call(this, forceUpdate);
  }
  get position3d() {
    return this.proj.position;
  }
  set position3d(value) {
    this.proj.position.copyFrom(value);
  }
  get scale3d() {
    return this.proj.scale;
  }
  set scale3d(value) {
    this.proj.scale.copyFrom(value);
  }
  get euler() {
    return this.proj.euler;
  }
  set euler(value) {
    this.proj.euler.copyFrom(value);
  }
  get pivot3d() {
    return this.proj.pivot;
  }
  set pivot3d(value) {
    this.proj.pivot.copyFrom(value);
  }
}
Text3d.prototype.calculateVertices = Sprite3d.prototype.calculateVertices;
Text3d.prototype.calculateTrimmedVertices = Sprite3d.prototype.calculateTrimmedVertices;
Text3d.prototype._calculateBounds = Sprite3d.prototype._calculateBounds;
Text3d.prototype.containsPoint = Sprite3d.prototype.containsPoint;
Text3d.prototype._render = Sprite3d.prototype._render;

export { Text3d };
//# sourceMappingURL=Text3d.mjs.map
