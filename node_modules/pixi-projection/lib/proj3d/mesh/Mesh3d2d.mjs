import { Mesh, MeshGeometry, MeshMaterial } from '@pixi/mesh';
import { Program } from '@pixi/core';
import { Projection3d } from '../Projection3d.mjs';
import '../../base/index.mjs';
import { container3dToLocal, container3dIsFrontFace, container3dGetDepth } from '../Container3d.mjs';
import '../../proj2d/index.mjs';
import { Mesh2d } from '../../proj2d/mesh/Mesh2d.mjs';
import { TRANSFORM_STEP } from '../../base/AbstractProjection.mjs';

class Mesh3d2d extends Mesh {
  constructor(geometry, shader, state, drawMode) {
    super(geometry, shader, state, drawMode);
    this.vertexData2d = null;
    this.proj = new Projection3d(this.transform);
  }
  calculateVertices() {
    if (this.proj._affine) {
      this.vertexData2d = null;
      super.calculateVertices();
      return;
    }
    const geometry = this.geometry;
    const vertices = geometry.buffers[0].data;
    const thisAny = this;
    if (geometry.vertexDirtyId === thisAny.vertexDirty && thisAny._transformID === thisAny.transform._worldID) {
      return;
    }
    thisAny._transformID = thisAny.transform._worldID;
    if (thisAny.vertexData.length !== vertices.length) {
      thisAny.vertexData = new Float32Array(vertices.length);
    }
    if (!this.vertexData2d || this.vertexData2d.length !== vertices.length * 3 / 2) {
      this.vertexData2d = new Float32Array(vertices.length * 3);
    }
    const wt = this.proj.world.mat4;
    const vertexData2d = this.vertexData2d;
    const vertexData = thisAny.vertexData;
    for (let i = 0; i < vertexData.length / 2; i++) {
      const x = vertices[i * 2];
      const y = vertices[i * 2 + 1];
      const xx = wt[0] * x + wt[4] * y + wt[12];
      const yy = wt[1] * x + wt[5] * y + wt[13];
      const ww = wt[3] * x + wt[7] * y + wt[15];
      vertexData2d[i * 3] = xx;
      vertexData2d[i * 3 + 1] = yy;
      vertexData2d[i * 3 + 2] = ww;
      vertexData[i * 2] = xx / ww;
      vertexData[i * 2 + 1] = yy / ww;
    }
    thisAny.vertexDirty = geometry.vertexDirtyId;
  }
  get worldTransform() {
    return this.proj.affine ? this.transform.worldTransform : this.proj.world;
  }
  toLocal(position, from, point, skipUpdate, step = TRANSFORM_STEP.ALL) {
    return container3dToLocal.call(this, position, from, point, skipUpdate, step);
  }
  isFrontFace(forceUpdate) {
    return container3dIsFrontFace.call(this, forceUpdate);
  }
  getDepth(forceUpdate) {
    return container3dGetDepth.call(this, forceUpdate);
  }
  get position3d() {
    return this.proj.position;
  }
  set position3d(value) {
    this.proj.position.copyFrom(value);
  }
  get scale3d() {
    return this.proj.scale;
  }
  set scale3d(value) {
    this.proj.scale.copyFrom(value);
  }
  get euler() {
    return this.proj.euler;
  }
  set euler(value) {
    this.proj.euler.copyFrom(value);
  }
  get pivot3d() {
    return this.proj.pivot;
  }
  set pivot3d(value) {
    this.proj.pivot.copyFrom(value);
  }
}
Mesh3d2d.prototype._renderDefault = Mesh2d.prototype._renderDefault;
class SimpleMesh3d2d extends Mesh3d2d {
  constructor(texture, vertices, uvs, indices, drawMode) {
    super(
      new MeshGeometry(vertices, uvs, indices),
      new MeshMaterial(texture, {
        program: Program.from(Mesh2d.defaultVertexShader, Mesh2d.defaultFragmentShader),
        pluginName: "batch2d"
      }),
      null,
      drawMode
    );
    this.autoUpdate = true;
    this.geometry.getBuffer("aVertexPosition").static = false;
  }
  get vertices() {
    return this.geometry.getBuffer("aVertexPosition").data;
  }
  set vertices(value) {
    this.geometry.getBuffer("aVertexPosition").data = value;
  }
  _render(renderer) {
    if (this.autoUpdate) {
      this.geometry.getBuffer("aVertexPosition").update();
    }
    super._render(renderer);
  }
}

export { Mesh3d2d, SimpleMesh3d2d };
//# sourceMappingURL=Mesh3d2d.mjs.map
