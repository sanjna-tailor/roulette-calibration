import { IPointData, Matrix, Point } from '@pixi/math';
import { Matrix2d } from '../proj2d';
import { AFFINE } from '../base';
export declare class Matrix3d {
    static readonly IDENTITY: Matrix3d;
    static readonly TEMP_MATRIX: Matrix3d;
    mat4: Float64Array;
    floatArray: Float32Array;
    _dirtyId: number;
    _updateId: number;
    _mat4inv: Float64Array;
    cacheInverse: boolean;
    constructor(backingArray?: ArrayLike<number>);
    get a(): number;
    set a(value: number);
    get b(): number;
    set b(value: number);
    get c(): number;
    set c(value: number);
    get d(): number;
    set d(value: number);
    get tx(): number;
    set tx(value: number);
    get ty(): number;
    set ty(value: number);
    set(a: number, b: number, c: number, d: number, tx: number, ty: number): this;
    toArray(transpose?: boolean, out?: Float32Array): Float32Array;
    setToTranslation(tx: number, ty: number, tz: number): void;
    setToRotationTranslationScale(quat: Float64Array, tx: number, ty: number, tz: number, sx: number, sy: number, sz: number): Float64Array;
    apply(pos: IPointData, newPos: IPointData): IPointData;
    translate(tx: number, ty: number, tz: number): this;
    scale(x: number, y: number, z?: number): this;
    scaleAndTranslate(scaleX: number, scaleY: number, scaleZ: number, tx: number, ty: number, tz: number): void;
    applyInverse<P extends IPointData = Point>(pos: IPointData, newPos?: P): P;
    invert(): Matrix3d;
    invertCopyTo(matrix: Matrix3d): void;
    identity(): Matrix3d;
    clone(): Matrix3d;
    copyTo3d(matrix: Matrix3d): Matrix3d;
    copyTo2d(matrix: Matrix2d): Matrix2d;
    copyTo2dOr3d<P extends Matrix2d | Matrix3d>(matrix: P): P;
    copyTo(matrix: Matrix, affine?: AFFINE, preserveOrientation?: boolean): Matrix;
    copyFrom(matrix: Matrix): this;
    setToMultLegacy(pt: Matrix, lt: Matrix3d): this;
    setToMultLegacy2(pt: Matrix3d, lt: Matrix): this;
    setToMult(pt: Matrix3d, lt: Matrix3d): this;
    prepend(lt: any): void;
    static glMatrixMat4Invert(out: Float64Array, a: Float64Array): Float64Array;
    static glMatrixMat4Multiply(out: Float64Array, a: Float64Array, b: Float64Array): Float64Array;
}
