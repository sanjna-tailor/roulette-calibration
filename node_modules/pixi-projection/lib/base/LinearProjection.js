'use strict';

var AbstractProjection = require('./AbstractProjection.js');
var math = require('@pixi/math');

var AFFINE = /* @__PURE__ */ ((AFFINE2) => {
  AFFINE2[AFFINE2["NONE"] = 0] = "NONE";
  AFFINE2[AFFINE2["FREE"] = 1] = "FREE";
  AFFINE2[AFFINE2["AXIS_X"] = 2] = "AXIS_X";
  AFFINE2[AFFINE2["AXIS_Y"] = 3] = "AXIS_Y";
  AFFINE2[AFFINE2["POINT"] = 4] = "POINT";
  AFFINE2[AFFINE2["AXIS_XR"] = 5] = "AXIS_XR";
  return AFFINE2;
})(AFFINE || {});
function transformHack(parentTransform) {
  const proj = this.proj;
  const ta = this;
  const pwid = parentTransform._worldID;
  const lt = ta.localTransform;
  const scaleAfterAffine = proj.scaleAfterAffine && proj.affine >= 2;
  if (ta._localID !== ta._currentLocalID) {
    if (scaleAfterAffine) {
      lt.a = ta._cx;
      lt.b = ta._sx;
      lt.c = ta._cy;
      lt.d = ta._sy;
      lt.tx = ta.position._x;
      lt.ty = ta.position._y;
    } else {
      lt.a = ta._cx * ta.scale._x;
      lt.b = ta._sx * ta.scale._x;
      lt.c = ta._cy * ta.scale._y;
      lt.d = ta._sy * ta.scale._y;
      lt.tx = ta.position._x - (ta.pivot._x * lt.a + ta.pivot._y * lt.c);
      lt.ty = ta.position._y - (ta.pivot._x * lt.b + ta.pivot._y * lt.d);
    }
    ta._currentLocalID = ta._localID;
    proj._currentProjID = -1;
  }
  const _matrixID = proj._projID;
  if (proj._currentProjID !== _matrixID) {
    proj._currentProjID = _matrixID;
    proj.updateLocalTransform(lt);
    ta._parentID = -1;
  }
  if (ta._parentID !== pwid) {
    const pp = parentTransform.proj;
    if (pp && !pp._affine) {
      proj.world.setToMult(pp.world, proj.local);
    } else {
      proj.world.setToMultLegacy(parentTransform.worldTransform, proj.local);
    }
    const wa = ta.worldTransform;
    proj.world.copyTo(wa, proj._affine, proj.affinePreserveOrientation);
    if (scaleAfterAffine) {
      wa.a *= ta.scale._x;
      wa.b *= ta.scale._x;
      wa.c *= ta.scale._y;
      wa.d *= ta.scale._y;
      wa.tx -= ta.pivot._x * wa.a + ta.pivot._y * wa.c;
      wa.ty -= ta.pivot._x * wa.b + ta.pivot._y * wa.d;
    }
    ta._parentID = pwid;
    ta._worldID++;
  }
}
class LinearProjection extends AbstractProjection.AbstractProjection {
  constructor() {
    super(...arguments);
    this._projID = 0;
    this._currentProjID = -1;
    this._affine = 0 /* NONE */;
    this.affinePreserveOrientation = false;
    this.scaleAfterAffine = true;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateLocalTransform(lt) {
  }
  set affine(value) {
    if (this._affine === value)
      return;
    this._affine = value;
    this._currentProjID = -1;
    this.legacy._currentLocalID = -1;
  }
  get affine() {
    return this._affine;
  }
  // eslint-disable-next-line accessor-pairs
  set enabled(value) {
    if (value === this._enabled) {
      return;
    }
    this._enabled = value;
    if (value) {
      this.legacy.updateTransform = transformHack;
      this.legacy._parentID = -1;
    } else {
      this.legacy.updateTransform = math.Transform.prototype.updateTransform;
      this.legacy._parentID = -1;
    }
  }
  clear() {
    this._currentProjID = -1;
    this._projID = 0;
  }
}

exports.AFFINE = AFFINE;
exports.LinearProjection = LinearProjection;
exports.transformHack = transformHack;
//# sourceMappingURL=LinearProjection.js.map
